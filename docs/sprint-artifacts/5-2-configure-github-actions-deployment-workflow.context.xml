<?xml version="1.0" encoding="UTF-8"?>
<!--
  Story Context Document
  Generated: 2025-12-05
  Story: 5-2-configure-github-actions-deployment-workflow
  Epic: 5 - CI/CD Staging Deployment
-->
<story-context story-id="5-2" version="1.0">
  <metadata>
    <title>Configure GitHub Actions Deployment Workflow</title>
    <epic>Epic 5: CI/CD Staging Deployment</epic>
    <status>drafted</status>
    <generated-date>2025-12-05</generated-date>
    <dependencies>
      <dependency story-id="5-1" status="done">Select Staging Platform</dependency>
    </dependencies>
  </metadata>

  <story-summary>
    <user-story>
      As a DevOps engineer, I want a GitHub Actions workflow for staging deployment,
      so that merges to main trigger automatic deployments.
    </user-story>
    <acceptance-criteria>
      <criterion id="AC1">Workflow triggers on push to main branch</criterion>
      <criterion id="AC2">Workflow runs after CI checks pass</criterion>
      <criterion id="AC3">Workflow deploys web to Vercel</criterion>
      <criterion id="AC4">Workflow deploys API to Railway</criterion>
      <criterion id="AC5">Workflow reports deployment status</criterion>
      <criterion id="AC6">Workflow uses GitHub environment secrets (not hardcoded)</criterion>
      <criterion id="AC7">Deployment is verified via health check endpoint</criterion>
    </acceptance-criteria>
  </story-summary>

  <architectural-context>
    <decision-reference doc="docs/architecture-decisions.md" section="Epic 5: CI/CD Staging Deployment">
      <summary>Two-target deployment strategy: Primary (Vercel + Railway), Secondary (Railway + Railway)</summary>
      <key-decisions>
        <decision>Web app deploys to Vercel (zero-config Next.js deployment)</decision>
        <decision>API server deploys to Railway (Docker container, long-running process)</decision>
        <decision>Supabase TEST project used for staging database</decision>
        <decision>No cold starts for API (critical for mobile development)</decision>
      </key-decisions>
    </decision-reference>

    <deployment-targets>
      <primary-target>
        <web platform="Vercel">
          <rationale>Native Next.js 15 support, preview deployments, instant rollbacks</rationale>
          <config>Root Directory: apps/web, Build Command: pnpm exec nx build web</config>
        </web>
        <api platform="Railway">
          <rationale>Full Docker support, long-running process, no cold starts</rationale>
          <config>Dockerfile: apps/server/Dockerfile, Build Context: monorepo root</config>
        </api>
      </primary-target>
      <secondary-target note="Implement if time permits">
        <web platform="Railway">Docker container using apps/web/Dockerfile</web>
        <api platform="Railway">Docker container using apps/server/Dockerfile</api>
      </secondary-target>
    </deployment-targets>
  </architectural-context>

  <technical-specifications>
    <github-actions>
      <existing-workflows>
        <workflow file=".github/workflows/ci.yml">
          <purpose>CI pipeline: lint, test, build, typecheck, e2e</purpose>
          <triggers>push to main, pull_request</triggers>
          <relevant-jobs>
            <job>main: Runs lint, test, build, typecheck, e2e</job>
          </relevant-jobs>
        </workflow>
        <workflow file=".github/workflows/claude.yml">Claude Code integration</workflow>
        <workflow file=".github/workflows/claude-code-review.yml">Claude Code review</workflow>
      </existing-workflows>

      <new-workflow file=".github/workflows/deploy-staging.yml">
        <triggers>
          <trigger>workflow_run: After CI completes successfully on main</trigger>
        </triggers>
        <jobs>
          <job name="deploy-web">
            <steps>
              <step>Checkout code</step>
              <step>Deploy to Vercel using Vercel CLI or GitHub integration</step>
              <step>Wait for deployment to complete</step>
              <step>Verify deployment via health check</step>
            </steps>
          </job>
          <job name="deploy-api">
            <steps>
              <step>Checkout code</step>
              <step>Deploy to Railway using Railway CLI or GitHub integration</step>
              <step>Wait for deployment to complete</step>
              <step>Verify deployment via /api/health endpoint</step>
            </steps>
          </job>
        </jobs>
        <environment-strategy>
          <github-environment name="staging">
            <secrets>
              <secret name="VERCEL_TOKEN">Vercel deployment token</secret>
              <secret name="VERCEL_ORG_ID">Vercel organization ID</secret>
              <secret name="VERCEL_PROJECT_ID">Vercel project ID</secret>
              <secret name="RAILWAY_TOKEN">Railway deployment token</secret>
              <secret name="RAILWAY_SERVICE_ID">Railway service ID for API</secret>
            </secrets>
            <variables>
              <variable name="STAGING_WEB_URL">https://your-app.vercel.app</variable>
              <variable name="STAGING_API_URL">https://your-api.railway.app</variable>
            </variables>
          </github-environment>
        </environment-strategy>
      </new-workflow>
    </github-actions>

    <vercel-configuration>
      <setup>
        <step>Connect GitHub repository to Vercel</step>
        <step>Configure root directory as apps/web</step>
        <step>Set framework preset to Next.js</step>
        <step>Configure environment variables in Vercel dashboard</step>
      </setup>
      <environment-variables>
        <variable name="NEXT_PUBLIC_API_URL">Railway API URL</variable>
        <variable name="NEXT_PUBLIC_SUPABASE_URL">Supabase TEST project URL</variable>
        <variable name="NEXT_PUBLIC_SUPABASE_ANON_KEY">Supabase anon key</variable>
      </environment-variables>
      <nx-integration>
        <note>Vercel auto-detects Nx monorepo structure</note>
        <note>Uses nx-ignore for selective builds based on affected projects</note>
      </nx-integration>
    </vercel-configuration>

    <railway-configuration>
      <setup>
        <step>Create Railway project</step>
        <step>Connect to GitHub repository</step>
        <step>Configure Dockerfile path: apps/server/Dockerfile</step>
        <step>Set build context to monorepo root</step>
        <step>Configure environment variables</step>
      </setup>
      <environment-variables>
        <variable name="DATABASE_URL">Supabase TEST pooler connection (port 6543)</variable>
        <variable name="DIRECT_URL">Supabase TEST direct connection (port 5432)</variable>
        <variable name="SUPABASE_URL">Supabase TEST project URL</variable>
        <variable name="SUPABASE_SERVICE_ROLE_KEY">Supabase service role key</variable>
        <variable name="NODE_ENV">production</variable>
        <variable name="PORT">4000</variable>
      </environment-variables>
      <health-check>
        <endpoint>/api/health</endpoint>
        <interval>30s</interval>
        <timeout>3s</timeout>
      </health-check>
    </railway-configuration>
  </technical-specifications>

  <codebase-context>
    <existing-files>
      <file path=".github/workflows/ci.yml" relevance="high">
        <description>Current CI workflow - deployment should run after this passes</description>
      </file>
      <file path="apps/server/Dockerfile" relevance="high">
        <description>Server Dockerfile created in story 5-3 (dependency)</description>
        <status>EXISTS - Created during partial 5-3 implementation</status>
      </file>
      <file path="apps/web/Dockerfile" relevance="medium">
        <description>Web Dockerfile for secondary target (Railway deployment)</description>
        <status>EXISTS - Created during partial 5-3 implementation</status>
      </file>
      <file path="apps/web/next.config.js" relevance="medium">
        <description>Next.js config - may need output: 'standalone' for Docker</description>
      </file>
      <file path="docker-compose.yml" relevance="low">
        <description>Local development Docker Compose - reference for env vars</description>
      </file>
    </existing-files>

    <api-endpoints>
      <endpoint path="/api/health" method="GET">
        <description>Health check endpoint for deployment verification</description>
        <expected-response>JSON with status and timestamp</expected-response>
      </endpoint>
      <endpoint path="/health" method="GET" app="web">
        <description>Web app health page for Vercel deployment verification</description>
      </endpoint>
    </api-endpoints>
  </codebase-context>

  <implementation-guidance>
    <approach>
      <step order="1">Create GitHub Actions workflow file deploy-staging.yml</step>
      <step order="2">Configure workflow to trigger after CI success on main</step>
      <step order="3">Set up Vercel deployment job (can use Vercel GitHub integration)</step>
      <step order="4">Set up Railway deployment job using Railway CLI</step>
      <step order="5">Add health check verification steps</step>
      <step order="6">Configure GitHub environment secrets</step>
      <step order="7">Test deployment by pushing to main</step>
    </approach>

    <deployment-options>
      <option name="Vercel GitHub Integration" recommended="true">
        <description>Let Vercel handle deployments automatically via GitHub integration</description>
        <pros>Simpler setup, automatic preview deployments, better Vercel features</pros>
        <cons>Less control in workflow, deployment status reporting more complex</cons>
      </option>
      <option name="Vercel CLI in GitHub Actions">
        <description>Use vercel CLI directly in workflow for full control</description>
        <pros>Full control, explicit deployment steps, better status reporting</pros>
        <cons>More complex setup, need to manage Vercel tokens</cons>
      </option>
    </deployment-options>

    <considerations>
      <consideration type="security">
        <title>Secrets Management</title>
        <detail>All deployment tokens must be stored as GitHub environment secrets, never hardcoded</detail>
      </consideration>
      <consideration type="reliability">
        <title>Deployment Verification</title>
        <detail>Include health check verification to confirm deployments are successful</detail>
      </consideration>
      <consideration type="dx">
        <title>Deployment Status</title>
        <detail>Consider GitHub deployment environments for status tracking in PRs</detail>
      </consideration>
    </considerations>
  </implementation-guidance>

  <validation-checklist>
    <item id="V1">deploy-staging.yml workflow file exists in .github/workflows/</item>
    <item id="V2">Workflow triggers on push to main (after CI passes)</item>
    <item id="V3">GitHub environment 'staging' exists with required secrets</item>
    <item id="V4">Vercel deployment job completes successfully</item>
    <item id="V5">Railway deployment job completes successfully</item>
    <item id="V6">Web health check passes after Vercel deployment</item>
    <item id="V7">API health check passes after Railway deployment</item>
    <item id="V8">No hardcoded secrets in workflow file</item>
    <item id="V9">Deployment status visible in GitHub Actions UI</item>
  </validation-checklist>

  <references>
    <doc path="docs/architecture-decisions.md" section="Epic 5: CI/CD Staging Deployment">Platform selection decisions</doc>
    <doc path="docs/epics.md" section="Story 5.2">Story definition and acceptance criteria</doc>
    <doc path=".github/workflows/ci.yml">Existing CI workflow to integrate with</doc>
  </references>
</story-context>
