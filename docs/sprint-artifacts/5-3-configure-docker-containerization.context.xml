<?xml version="1.0" encoding="UTF-8"?>
<!--
  Story Context Document
  Generated: 2025-12-05
  Story: 5-3-configure-docker-containerization
  Epic: 5 - CI/CD Staging Deployment

  IMPORTANT: Partial implementation exists. This context supports VALIDATION
  of existing work against acceptance criteria.
-->
<story-context story-id="5-3" version="1.0">
  <metadata>
    <title>Configure Docker Containerization</title>
    <epic>Epic 5: CI/CD Staging Deployment</epic>
    <status>drafted</status>
    <generated-date>2025-12-05</generated-date>
    <implementation-status>
      <note>PARTIAL IMPLEMENTATION EXISTS - Tasks 1-4, 7-8 completed without proper BMAD process</note>
      <note>Tasks 5-6 BLOCKED - Docker not available in WSL environment</note>
      <note>This context enables validation of existing work</note>
    </implementation-status>
    <dependencies>
      <dependency story-id="5-1" status="done">Select Staging Platform</dependency>
    </dependencies>
  </metadata>

  <story-summary>
    <user-story>
      As a DevOps engineer, I want Docker configuration for the applications,
      so that deployments are consistent and portable.
    </user-story>
    <acceptance-criteria>
      <criterion id="AC1">Dockerfile(s) exist for server and web applications</criterion>
      <criterion id="AC2">Containers can be built successfully locally</criterion>
      <criterion id="AC3">Containers include only production dependencies</criterion>
      <criterion id="AC4">Health check endpoints respond correctly in container</criterion>
      <criterion id="AC5">docker-compose or build scripts are documented</criterion>
    </acceptance-criteria>
  </story-summary>

  <architectural-context>
    <decision-reference doc="docs/architecture-decisions.md" section="Epic 5: CI/CD Staging Deployment">
      <summary>Docker containerization for consistent, portable deployment</summary>
      <key-decisions>
        <decision>Multi-stage builds for optimized image size</decision>
        <decision>Separate containers for web and API (not monolithic)</decision>
        <decision>Primary target: Server Dockerfile required immediately (Railway)</decision>
        <decision>Secondary target: Web Dockerfile for Railway deployment</decision>
        <decision>Vercel handles web deployment without Docker for primary target</decision>
      </key-decisions>
    </decision-reference>

    <docker-strategy>
      <primary-target>
        <server>Docker container on Railway (required)</server>
        <web>Vercel native deployment (no Docker needed)</web>
      </primary-target>
      <secondary-target>
        <server>Docker container on Railway</server>
        <web>Docker container on Railway (requires Dockerfile)</web>
      </secondary-target>
    </docker-strategy>
  </architectural-context>

  <existing-implementation>
    <status>PARTIAL - Created without proper BMAD process, needs validation</status>

    <created-files>
      <file path="apps/server/Dockerfile" status="EXISTS">
        <description>Multi-stage Docker build for Express API server</description>
        <highlights>
          <item>Uses node:22-alpine base image</item>
          <item>Multi-stage build: builder → runner</item>
          <item>pnpm via corepack for package management</item>
          <item>Prisma client generation in builder stage</item>
          <item>NX_DAEMON=false and NX_SKIP_NX_CACHE=true for Docker stability</item>
          <item>Non-root user (expressjs) for security</item>
          <item>Symlinks for @nx-monorepo/* workspace packages</item>
          <item>pnpm symlink fixes for strict isolation</item>
          <item>HEALTHCHECK configured for /api/health</item>
          <item>Exposes port 4000</item>
        </highlights>
        <complexity>HIGH - Complex symlink handling for pnpm + Nx monorepo</complexity>
      </file>

      <file path="apps/web/Dockerfile" status="EXISTS">
        <description>Multi-stage Docker build for Next.js web application</description>
        <highlights>
          <item>Uses node:22-alpine base image</item>
          <item>Three-stage build: deps → builder → runner</item>
          <item>Requires dist/apps/server/openapi.json for api-client type generation</item>
          <item>Build args for NEXT_PUBLIC_* environment variables</item>
          <item>Next.js standalone output mode for Docker</item>
          <item>Non-root user (nextjs) for security</item>
          <item>HEALTHCHECK configured for /health</item>
          <item>Exposes port 3000</item>
        </highlights>
        <note>Created for secondary target (Railway + Railway) and forward-compatibility</note>
      </file>

      <file path="docker-compose.yml" status="EXISTS">
        <description>Docker Compose for local development and testing</description>
        <highlights>
          <item>Defines server and web services</item>
          <item>Configures environment variables from .env.docker</item>
          <item>Sets up app-network for container communication</item>
          <item>Health checks for both services</item>
          <item>Web depends_on server (healthy condition)</item>
        </highlights>
      </file>

      <file path=".dockerignore" status="EXISTS">
        <description>Optimized dockerignore for monorepo</description>
        <highlights>
          <item>Excludes node_modules, dist, .next (rebuilt in container)</item>
          <item>EXCEPTION: Includes dist/apps/server/openapi.json (needed for web build)</item>
          <item>Excludes test files, coverage, E2E tests</item>
          <item>Excludes environment files (except .env.example, .env.docker.example)</item>
          <item>Excludes docs, .github, tooling, mobile app</item>
          <item>Excludes Nx cache, IDE files, logs</item>
        </highlights>
      </file>

      <file path=".env.docker.example" status="EXISTS">
        <description>Template for Docker environment variables</description>
        <content-summary>
          <item>DATABASE_URL placeholder for Supabase pooler connection</item>
          <item>SUPABASE_URL and SUPABASE_ANON_KEY placeholders</item>
          <item>SENTRY_DSN and SENTRY_ENVIRONMENT (optional)</item>
          <item>Build-time NEXT_PUBLIC_* variable documentation</item>
        </content-summary>
      </file>
    </created-files>

    <blocked-tasks>
      <task id="5" status="BLOCKED">
        <title>Build and verify server container locally</title>
        <reason>Docker not available in WSL environment</reason>
        <workaround>Verify via Railway deployment (cloud Docker build)</workaround>
      </task>
      <task id="6" status="BLOCKED">
        <title>Build and verify web container locally</title>
        <reason>Docker not available in WSL environment</reason>
        <workaround>Verify via Railway deployment for secondary target</workaround>
      </task>
    </blocked-tasks>
  </existing-implementation>

  <technical-specifications>
    <server-dockerfile>
      <base-image>node:22-alpine</base-image>
      <stages>
        <stage name="builder">
          <purpose>Install dependencies and build application</purpose>
          <key-steps>
            <step>Enable corepack and prepare pnpm@9</step>
            <step>Copy workspace config files (pnpm-lock.yaml, nx.json, tsconfig.json)</step>
            <step>Copy server app and packages directories</step>
            <step>pnpm install --frozen-lockfile</step>
            <step>Prisma generate (using pinned version 6.17.1)</step>
            <step>Set NX_DAEMON=false, NX_SKIP_NX_CACHE=true</step>
            <step>nx sync (required for non-interactive builds)</step>
            <step>nx run server:build:production</step>
          </key-steps>
        </stage>
        <stage name="runner">
          <purpose>Minimal production runtime image</purpose>
          <key-steps>
            <step>Create non-root user (expressjs:nodejs)</step>
            <step>Copy built application from builder</step>
            <step>Copy node_modules from builder</step>
            <step>Create symlinks for @nx-monorepo/* packages</step>
            <step>Fix pnpm symlinks for strict isolation</step>
            <step>Re-generate Prisma client for alpine binaries</step>
            <step>Set ownership to non-root user</step>
            <step>Configure HEALTHCHECK</step>
          </key-steps>
        </stage>
      </stages>
      <exposed-port>4000</exposed-port>
      <health-check>
        <endpoint>/api/health</endpoint>
        <interval>30s</interval>
        <timeout>3s</timeout>
        <start-period>10s</start-period>
        <retries>3</retries>
      </health-check>
    </server-dockerfile>

    <web-dockerfile>
      <base-image>node:22-alpine</base-image>
      <stages>
        <stage name="deps">
          <purpose>Install all dependencies</purpose>
          <key-steps>
            <step>Copy workspace config and app files</step>
            <step>Copy openapi.json from dist (required for api-client)</step>
            <step>pnpm install --frozen-lockfile</step>
          </key-steps>
        </stage>
        <stage name="builder">
          <purpose>Build Next.js application</purpose>
          <key-steps>
            <step>Set NX_DAEMON=false, NX_SKIP_NX_CACHE=true</step>
            <step>nx sync</step>
            <step>Accept build args for NEXT_PUBLIC_* variables</step>
            <step>nx run web:build:production</step>
          </key-steps>
        </stage>
        <stage name="runner">
          <purpose>Minimal production runtime</purpose>
          <key-steps>
            <step>Create non-root user (nextjs:nodejs)</step>
            <step>Copy public assets</step>
            <step>Copy standalone build output</step>
            <step>Copy static files</step>
          </key-steps>
        </stage>
      </stages>
      <build-args>
        <arg name="NEXT_PUBLIC_API_URL">API server URL (baked into bundle)</arg>
        <arg name="NEXT_PUBLIC_SUPABASE_URL">Supabase project URL</arg>
        <arg name="NEXT_PUBLIC_SUPABASE_ANON_KEY">Supabase anon key</arg>
      </build-args>
      <exposed-port>3000</exposed-port>
      <health-check>
        <endpoint>/health</endpoint>
        <interval>30s</interval>
        <timeout>3s</timeout>
        <start-period>10s</start-period>
        <retries>3</retries>
      </health-check>
      <prerequisite>
        <item>dist/apps/server/openapi.json must exist (run server build first)</item>
        <item>Next.js output: 'standalone' must be configured</item>
      </prerequisite>
    </web-dockerfile>

    <docker-compose>
      <services>
        <service name="server">
          <build-context>.</build-context>
          <dockerfile>apps/server/Dockerfile</dockerfile>
          <port>4000:4000</port>
          <environment>NODE_ENV, PORT, HOST, DATABASE_URL, SUPABASE_*, SENTRY_*</environment>
          <healthcheck>/api/health</healthcheck>
        </service>
        <service name="web">
          <build-context>.</build-context>
          <dockerfile>apps/web/Dockerfile</dockerfile>
          <port>3000:3000</port>
          <build-args>NEXT_PUBLIC_API_URL=http://server:4000</build-args>
          <depends-on>server (healthy)</depends-on>
          <healthcheck>/health</healthcheck>
        </service>
      </services>
      <networks>
        <network name="app-network" driver="bridge"/>
      </networks>
    </docker-compose>

    <known-complexities>
      <complexity id="1" severity="high">
        <title>pnpm Symlink Resolution in Docker</title>
        <description>pnpm's strict isolation requires manual symlink creation for workspace packages and dependencies in production image</description>
        <solution>Explicit symlink commands in Dockerfile runner stage</solution>
      </complexity>
      <complexity id="2" severity="medium">
        <title>Nx Cache Race Condition</title>
        <description>Nx cache.js can cause EEXIST errors during parallel writes in Docker overlay filesystem</description>
        <solution>Set NX_SKIP_NX_CACHE=true in Docker builds</solution>
      </complexity>
      <complexity id="3" severity="medium">
        <title>Prisma Binary Compatibility</title>
        <description>Prisma client generates platform-specific binaries; builder stage binaries don't work in runner</description>
        <solution>Re-generate Prisma client in runner stage for alpine binaries</solution>
      </complexity>
      <complexity id="4" severity="medium">
        <title>OpenAPI Spec Dependency</title>
        <description>Web Dockerfile requires openapi.json from server build for api-client type generation</description>
        <solution>.dockerignore exception + documentation of build order</solution>
      </complexity>
    </known-complexities>
  </technical-specifications>

  <validation-requirements>
    <validation-approach>
      <note>Local Docker builds BLOCKED - validate via cloud deployment</note>
      <primary-validation>Deploy to Railway and verify health checks</primary-validation>
      <secondary-validation>Review Dockerfile contents against best practices</secondary-validation>
    </validation-approach>

    <validation-checklist>
      <section name="Dockerfile Structure">
        <item id="V1">Server Dockerfile exists at apps/server/Dockerfile</item>
        <item id="V2">Web Dockerfile exists at apps/web/Dockerfile</item>
        <item id="V3">Both use multi-stage builds</item>
        <item id="V4">Both use node:22-alpine base image</item>
        <item id="V5">Both create non-root users for security</item>
        <item id="V6">Both include HEALTHCHECK instructions</item>
      </section>

      <section name="Build Configuration">
        <item id="V7">NX_DAEMON=false set to prevent file watcher issues</item>
        <item id="V8">NX_SKIP_NX_CACHE=true set to prevent race conditions</item>
        <item id="V9">Prisma client generated with pinned version</item>
        <item id="V10">pnpm install uses --frozen-lockfile</item>
      </section>

      <section name="Production Optimization">
        <item id="V11">Only production dependencies in final image (devDependencies excluded)</item>
        <item id="V12">.dockerignore excludes test files, docs, and dev tooling</item>
        <item id="V13">Build artifacts properly copied to runner stage</item>
      </section>

      <section name="Documentation">
        <item id="V14">docker-compose.yml provides local testing capability</item>
        <item id="V15">.env.docker.example documents required environment variables</item>
        <item id="V16">Dockerfile headers include usage instructions</item>
      </section>

      <section name="Cloud Deployment Verification" note="Substitute for local Docker">
        <item id="V17">Server container builds successfully on Railway</item>
        <item id="V18">Server health check responds after deployment</item>
        <item id="V19">Web container builds successfully on Railway (secondary target)</item>
        <item id="V20">Web health check responds after deployment</item>
      </section>
    </validation-checklist>
  </validation-requirements>

  <implementation-guidance>
    <current-status>
      <completed-work>
        <item>Server Dockerfile (apps/server/Dockerfile) - complete</item>
        <item>Web Dockerfile (apps/web/Dockerfile) - complete</item>
        <item>docker-compose.yml - complete</item>
        <item>.dockerignore - complete</item>
        <item>.env.docker.example - complete</item>
      </completed-work>
      <remaining-work>
        <item>Validate server container build via Railway deployment</item>
        <item>Validate web container build via Railway deployment (secondary target)</item>
        <item>Update story status from 'blocked' to 'done' after validation</item>
      </remaining-work>
    </current-status>

    <validation-commands note="For when Docker becomes available">
      <command purpose="Build server container">
        docker build -f apps/server/Dockerfile -t nx-monorepo-server .
      </command>
      <command purpose="Build web container (requires server build first)">
        pnpm exec nx run server:build:production
        docker build -f apps/web/Dockerfile -t nx-monorepo-web .
      </command>
      <command purpose="Run full stack locally">
        cp .env.docker.example .env.docker
        # Edit .env.docker with real values
        docker compose up
      </command>
      <command purpose="Verify health checks">
        curl http://localhost:4000/api/health
        curl http://localhost:3000/health
      </command>
    </validation-commands>
  </implementation-guidance>

  <references>
    <doc path="docs/architecture-decisions.md" section="Epic 5">Platform and Docker strategy decisions</doc>
    <doc path="docs/epics.md" section="Story 5.3">Story definition and acceptance criteria</doc>
    <doc path="apps/server/Dockerfile">Server Dockerfile implementation</doc>
    <doc path="apps/web/Dockerfile">Web Dockerfile implementation</doc>
    <doc path="docker-compose.yml">Docker Compose configuration</doc>
    <doc path=".dockerignore">Docker build context exclusions</doc>
    <doc path=".env.docker.example">Environment variable template</doc>
  </references>
</story-context>
